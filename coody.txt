"""
نظام اكتشاف الثغرات الأمنية الذاتي التعلم
مشروع تخرج متقدم - إلغاء التدخل البشري بالكامل
"""

# ====================== المكتبات الأساسية ======================
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.distributions import Categorical, Normal
import gym
from gym import spaces
import matplotlib.pyplot as plt
import seaborn as sns
from collections import deque
import random
from datetime import datetime
import json
import pickle
import os
import warnings
import hashlib
import logging
import sys
import time
from tqdm import tqdm
import shutil
import csv
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

warnings.filterwarnings('ignore')

# ====================== إعدادات النظام المتقدمة ======================
class SystemConfig:
    def __init__(self):
        # إعدادات التعلم
        self.learning_rate = 0.001
        self.gamma = 0.99
        self.tau = 0.005
        
        # إعدادات الذاكرة
        self.memory_size = 100000
        self.batch_size = 128
        
        # إعدادات الشبكة
        self.hidden_size = 256
        self.num_actions = 12
        
        # إعدادات التدريب
        self.max_episodes = 2000
        self.max_steps = 200
        self.update_every = 50
        self.save_every = 100
        
        # إعدادات التكيف
        self.epsilon_start = 1.0
        self.epsilon_end = 0.01
        self.epsilon_decay = 0.995
        
        # إعدادات التقييم
        self.metrics_window = 100  # نافذة لحساب الدقة
        
        # إنشاء المجلدات
        self.create_folders()
    
    def create_folders(self):
        folders = ['models', 'data', 'logs', 'reports', 'backups', 'plots']
        for folder in folders:
            os.makedirs(folder, exist_ok=True)

# ====================== توليد البيانات الذاتي ======================
class DataGenerator:
    def __init__(self):
        self.vulnerabilities = {
            'SQL Injection': {'severity': 9, 'complexity': 7, 'patterns': ['SELECT', 'UNION', 'OR 1=1']},
            'XSS': {'severity': 7, 'complexity': 6, 'patterns': ['<script>', 'alert', 'onload']},
            'RCE': {'severity': 10, 'complexity': 9, 'patterns': ['system(', 'exec(', 'eval(']},
            'LFI': {'severity': 8, 'complexity': 6, 'patterns': ['../', 'etc/passwd', 'include']},
            'SSRF': {'severity': 8, 'complexity': 7, 'patterns': ['localhost', '127.0.0.1', 'internal']}
        }
        
        self.systems = {
            'Web Server': {'ports': [80, 443, 8080], 'services': ['Apache', 'Nginx', 'IIS']},
            'Database': {'ports': [3306, 5432, 27017], 'services': ['MySQL', 'PostgreSQL', 'MongoDB']},
            'Application': {'ports': [3000, 5000, 8000], 'services': ['Node.js', 'Python', 'Java']},
            'File Server': {'ports': [21, 22, 445], 'services': ['FTP', 'SSH', 'SMB']},
            'Mail Server': {'ports': [25, 110, 143], 'services': ['SMTP', 'POP3', 'IMAP']}
        }
        
        self.patterns_learned = []
        self.metrics_history = {
            'accuracy': [],
            'precision': [],
            'recall': [],
            'f1_score': [],
            'vulnerability_detection_rate': []
        }
        
    def generate_system(self):
        system_type = random.choice(list(self.systems.keys()))
        system_info = self.systems[system_type]
        
        # توليد عدد عشوائي من المنافذ المفتوحة
        num_ports = random.randint(2, len(system_info['ports']))
        open_ports = random.sample(system_info['ports'], num_ports)
        
        # توليد خدمات
        services = random.sample(system_info['services'], random.randint(1, len(system_info['services'])))
        
        # تحديد وجود ثغرة
        has_vulnerability = random.random() > 0.3
        
        vulnerability = None
        vulnerability_type = None
        vulnerability_details = None
        
        if has_vulnerability:
            vulnerability_type = random.choice(list(self.vulnerabilities.keys()))
            vulnerability = self.vulnerabilities[vulnerability_type]
            
            # إنشاء تفاصيل الثغرة
            vulnerability_details = {
                'type': vulnerability_type,
                'severity': vulnerability['severity'],
                'complexity': vulnerability['complexity'],
                'pattern': random.choice(vulnerability['patterns']),
                'port': random.choice(open_ports) if open_ports else 80,
                'exploitable': random.random() > 0.4
            }
        
        system = {
            'id': f"SYS_{random.randint(1000, 9999)}",
            'type': system_type,
            'open_ports': open_ports,
            'services': services,
            'os': random.choice(['Linux', 'Windows', 'macOS']),
            'has_vulnerability': has_vulnerability,
            'vulnerability': vulnerability_details,
            'security_level': random.randint(1, 10),
            'firewall': random.random() > 0.5,
            'ids': random.random() > 0.7
        }
        
        return system
    
    def calculate_accuracy_metrics(self, true_labels, predicted_labels):
        """حساب مقاييس الدقة"""
        if len(true_labels) == 0 or len(predicted_labels) == 0:
            return 0, 0, 0, 0
        
        try:
            accuracy = accuracy_score(true_labels, predicted_labels)
            precision = precision_score(true_labels, predicted_labels, zero_division=0)
            recall = recall_score(true_labels, predicted_labels, zero_division=0)
            f1 = f1_score(true_labels, predicted_labels, zero_division=0)
        except:
            accuracy = precision = recall = f1 = 0
        
        return accuracy, precision, recall, f1
    
    def update_metrics(self, true_labels, predicted_labels, vulnerability_detected=False):
        """تحديث المقاييس"""
        accuracy, precision, recall, f1 = self.calculate_accuracy_metrics(true_labels, predicted_labels)
        
        self.metrics_history['accuracy'].append(accuracy)
        self.metrics_history['precision'].append(precision)
        self.metrics_history['recall'].append(recall)
        self.metrics_history['f1_score'].append(f1)
        self.metrics_history['vulnerability_detection_rate'].append(1 if vulnerability_detected else 0)
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1
        }
    
    def generate_dataset(self, num_samples=1000):
        dataset = []
        
        for i in range(num_samples):
            system = self.generate_system()
            dataset.append(system)
            
            # تعلم الأنماط
            if system['has_vulnerability']:
                pattern = {
                    'system_type': system['type'],
                    'vulnerability': system['vulnerability']['type'],
                    'port': system['vulnerability']['port'],
                    'service': random.choice(system['services'])
                }
                self.patterns_learned.append(pattern)
        
        return dataset
    
    def save_patterns(self, filename='data/patterns.json'):
        with open(filename, 'w') as f:
            json.dump(self.patterns_learned, f, indent=2)
    
    def load_patterns(self, filename='data/patterns.json'):
        if os.path.exists(filename):
            with open(filename, 'r') as f:
                self.patterns_learned = json.load(f)
    
    def plot_metrics(self):
        """رسم مقاييس الدقة"""
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        
        # مخطط الدقة
        axes[0, 0].plot(self.metrics_history['accuracy'], color='blue', linewidth=2)
        axes[0, 0].set_title('Model Accuracy Over Time', fontsize=14, fontweight='bold')
        axes[0, 0].set_xlabel('Episode', fontsize=12)
        axes[0, 0].set_ylabel('Accuracy', fontsize=12)
        axes[0, 0].grid(True, alpha=0.3)
        axes[0, 0].axhline(y=np.mean(self.metrics_history['accuracy']), color='red', linestyle='--', 
                          label=f'Mean: {np.mean(self.metrics_history["accuracy"]):.3f}')
        axes[0, 0].legend()
        
        # مخطط Precision
        axes[0, 1].plot(self.metrics_history['precision'], color='green', linewidth=2)
        axes[0, 1].set_title('Precision Score', fontsize=14, fontweight='bold')
        axes[0, 1].set_xlabel('Episode', fontsize=12)
        axes[0, 1].set_ylabel('Precision', fontsize=12)
        axes[0, 1].grid(True, alpha=0.3)
        
        # مخطط Recall
        axes[0, 2].plot(self.metrics_history['recall'], color='orange', linewidth=2)
        axes[0, 2].set_title('Recall Score', fontsize=14, fontweight='bold')
        axes[0, 2].set_xlabel('Episode', fontsize=12)
        axes[0, 2].set_ylabel('Recall', fontsize=12)
        axes[0, 2].grid(True, alpha=0.3)
        
        # مخطط F1 Score
        axes[1, 0].plot(self.metrics_history['f1_score'], color='purple', linewidth=2)
        axes[1, 0].set_title('F1 Score', fontsize=14, fontweight='bold')
        axes[1, 0].set_xlabel('Episode', fontsize=12)
        axes[1, 0].set_ylabel('F1 Score', fontsize=12)
        axes[1, 0].grid(True, alpha=0.3)
        
        # مخطط معدل اكتشاف الثغرات
        detection_rate = pd.Series(self.metrics_history['vulnerability_detection_rate']).rolling(50).mean()
        axes[1, 1].plot(detection_rate, color='red', linewidth=2)
        axes[1, 1].set_title('Vulnerability Detection Rate (50-episode moving avg)', fontsize=14, fontweight='bold')
        axes[1, 1].set_xlabel('Episode', fontsize=12)
        axes[1, 1].set_ylabel('Detection Rate', fontsize=12)
        axes[1, 1].grid(True, alpha=0.3)
        
        # مخطط توزيع الدقة
        axes[1, 2].hist(self.metrics_history['accuracy'], bins=20, edgecolor='black', color='skyblue', alpha=0.7)
        axes[1, 2].set_title('Accuracy Distribution', fontsize=14, fontweight='bold')
        axes[1, 2].set_xlabel('Accuracy', fontsize=12)
        axes[1, 2].set_ylabel('Frequency', fontsize=12)
        axes[1, 2].grid(True, alpha=0.3)
        axes[1, 2].axvline(x=np.mean(self.metrics_history['accuracy']), color='red', linestyle='--', 
                          label=f'Mean: {np.mean(self.metrics_history["accuracy"]):.3f}')
        axes[1, 2].legend()
        
        plt.suptitle('Vulnerability Detection System - Performance Metrics', fontsize=16, fontweight='bold', y=1.02)
        plt.tight_layout()
        plt.savefig('plots/accuracy_metrics.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return fig

# ====================== بيئة التعلم المعزز ======================
class VulnerabilityEnv(gym.Env):
    def __init__(self, data_generator):
        super(VulnerabilityEnv, self).__init__()
        
        self.data_generator = data_generator
        self.current_system = None
        self.steps_taken = 0
        self.discovered_ports = []
        self.discovered_services = []
        self.found_vulnerabilities = []
        self.access_level = 0  # 0: لا يوجد وصول، 1: وصول جزئي، 2: وصول كامل
        
        # إحصائيات الدقة
        self.accuracy_metrics = {
            'true_positives': 0,
            'false_positives': 0,
            'true_negatives': 0,
            'false_negatives': 0,
            'total_tests': 0
        }
        
        # تعريف مساحة الحالة
        self.observation_space = spaces.Box(
            low=0, high=1, shape=(20,), dtype=np.float32
        )
        
        # تعريف مساحة الإجراءات
        self.action_space = spaces.Discrete(12)
        
        self.action_descriptions = [
            "Fast Port Scan",
            "Deep Port Scan",
            "Service Inspection",
            "SQL Injection Test",
            "XSS Test",
            "RCE Test",
            "LFI Test",
            "SSRF Test",
            "Exploit Vulnerability",
            "Privilege Escalation",
            "Establish Access",
            "Maintain Stealth"
        ]
        
        self.reset()
    
    def reset(self):
        self.current_system = self.data_generator.generate_system()
        self.steps_taken = 0
        self.discovered_ports = []
        self.discovered_services = []
        self.found_vulnerabilities = []
        self.access_level = 0
        
        return self._get_state()
    
    def _get_state(self):
        state = np.zeros(20, dtype=np.float32)
        
        # نظام التشغيل (one-hot encoding)
        os_types = ['Linux', 'Windows', 'macOS']
        if self.current_system['os'] in os_types:
            state[os_types.index(self.current_system['os'])] = 1.0
        
        # نوع النظام (one-hot encoding)
        system_types = list(self.data_generator.systems.keys())
        if self.current_system['type'] in system_types:
            state[3 + system_types.index(self.current_system['type'])] = 1.0
        
        # نسبة الاكتشاف
        if self.current_system['open_ports']:
            state[8] = len(self.discovered_ports) / len(self.current_system['open_ports'])
        
        if self.current_system['services']:
            state[9] = len(self.discovered_services) / len(self.current_system['services'])
        
        # مستوى الأمان
        state[10] = self.current_system['security_level'] / 10.0
        
        # وجود جدار ناري
        state[11] = 1.0 if self.current_system['firewall'] else 0.0
        
        # وجود نظام كشف
        state[12] = 1.0 if self.current_system['ids'] else 0.0
        
        # مستوى الوصول
        state[13] = self.access_level / 2.0
        
        # عدد الخطوات
        state[14] = self.steps_taken / 50.0
        
        # وجود ثغرة
        state[15] = 1.0 if self.current_system['has_vulnerability'] else 0.0
        
        # عدد الثغرات المكتشفة
        state[16] = len(self.found_vulnerabilities) / 3.0
        
        # تعقيد النظام
        complexity = len(self.current_system['open_ports']) * 0.1
        complexity += len(self.current_system['services']) * 0.1
        state[17] = min(1.0, complexity)
        
        # القيم العشوائية (لإضافة تنوع)
        state[18] = random.random()
        state[19] = random.random()
        
        return state
    
    def step(self, action):
        self.steps_taken += 1
        reward = 0
        done = False
        info = {'action': self.action_descriptions[action]}
        
        # تنفيذ الإجراء
        if action == 0:  # مسح المنافذ السريع
            reward = self._fast_scan()
        elif action == 1:  # مسح المنافذ العميق
            reward = self._deep_scan()
        elif action == 2:  # فحص الخدمات
            reward = self._service_scan()
        elif action in [3, 4, 5, 6, 7]:  # اختبارات الثغرات
            vuln_type = ['SQL Injection', 'XSS', 'RCE', 'LFI', 'SSRF'][action-3]
            reward = self._test_vulnerability(vuln_type)
            self._update_accuracy_metrics(action-3, vuln_type)
        elif action == 8:  # استغلال الثغرة
            reward = self._exploit_vulnerability()
        elif action == 9:  # تصعيد الصلاحيات
            reward = self._escalate_privileges()
        elif action == 10:  # تثبيت وصول
            reward = self._establish_access()
        elif action == 11:  # المحافظة على التخفي
            reward = self._maintain_stealth()
        
        # عقوبة الوقت
        reward -= 0.01
        
        # التحقق من انتهاء الحلقة
        if self.steps_taken >= 50:
            done = True
            # مكافأة إضافية للإنجازات
            if len(self.found_vulnerabilities) > 0:
                reward += 1.0
            if self.access_level == 2:
                reward += 2.0
        
        # تحديث المعلومات
        info['reward'] = reward
        info['steps'] = self.steps_taken
        info['access_level'] = self.access_level
        info['vulnerabilities_found'] = len(self.found_vulnerabilities)
        
        # إضافة مقاييس الدقة
        info['accuracy_metrics'] = self.get_accuracy_metrics()
        
        return self._get_state(), reward, done, info
    
    def _update_accuracy_metrics(self, test_index, test_type):
        """تحديث مقاييس الدقة للاختبارات"""
        self.accuracy_metrics['total_tests'] += 1
        
        if self.current_system['has_vulnerability']:
            actual_vuln = self.current_system['vulnerability']['type']
            vuln_types = ['SQL Injection', 'XSS', 'RCE', 'LFI', 'SSRF']
            
            if test_type == actual_vuln:
                self.accuracy_metrics['true_positives'] += 1
            else:
                self.accuracy_metrics['false_positives'] += 1
        else:
            self.accuracy_metrics['false_positives'] += 1
    
    def get_accuracy_metrics(self):
        """الحصول على مقاييس الدقة الحالية"""
        total = self.accuracy_metrics['total_tests']
        if total == 0:
            return {
                'accuracy': 0,
                'precision': 0,
                'recall': 0,
                'f1_score': 0,
                'confusion_matrix': None
            }
        
        tp = self.accuracy_metrics['true_positives']
        fp = self.accuracy_metrics['false_positives']
        
        # حساب المقاييس
        accuracy = tp / total if total > 0 else 0
        precision = tp / (tp + fp) if (tp + fp) > 0 else 0
        
        # حساب recall و f1 (نحتاج true positives و false negatives)
        # سنقوم بتقديرها
        fn = self.accuracy_metrics['false_negatives'] if hasattr(self, 'false_negatives') else 0
        recall = tp / (tp + fn) if (tp + fn) > 0 else 0
        f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1,
            'true_positives': tp,
            'false_positives': fp,
            'total_tests': total
        }
    
    def _fast_scan(self):
        reward = 0
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3389]
        
        for port in common_ports:
            if port in self.current_system['open_ports'] and port not in self.discovered_ports:
                self.discovered_ports.append(port)
                reward += 0.1
        
        return reward
    
    def _deep_scan(self):
        reward = 0
        
        for port in self.current_system['open_ports']:
            if port not in self.discovered_ports:
                self.discovered_ports.append(port)
                reward += 0.05
        
        return reward
    
    def _service_scan(self):
        reward = 0
        
        if len(self.discovered_ports) > 0:
            for service in self.current_system['services']:
                if service not in self.discovered_services:
                    self.discovered_services.append(service)
                    reward += 0.2
        
        return reward
    
    def _test_vulnerability(self, vuln_type):
        reward = 0
        
        if self.current_system['has_vulnerability']:
            if self.current_system['vulnerability']['type'] == vuln_type:
                if vuln_type not in self.found_vulnerabilities:
                    self.found_vulnerabilities.append(vuln_type)
                    reward += 1.0
            else:
                reward -= 0.1  # عقوبة لاختبار خاطئ
        
        return reward
    
    def _exploit_vulnerability(self):
        reward = 0
        
        if len(self.found_vulnerabilities) > 0:
            if self.current_system['vulnerability']['exploitable']:
                self.access_level = 1
                reward += 2.0
            else:
                reward -= 0.5
        
        return reward
    
    def _escalate_privileges(self):
        reward = 0
        
        if self.access_level == 1:
            if random.random() > 0.5:  # 50% فرصة للنجاح
                self.access_level = 2
                reward += 3.0
            else:
                reward -= 1.0
        
        return reward
    
    def _establish_access(self):
        reward = 0
        
        if self.access_level == 2:
            reward += 1.0  # مكافأة إضافية لتثبيت الوصول
        
        return reward
    
    def _maintain_stealth(self):
        reward = 0
        
        # تقليل فرصة الاكتشاف
        if random.random() > 0.8:  # 20% فرصة للاكتشاف
            reward += 0.5
        
        return reward
    
    def render(self, mode='human'):
        print(f"\n=== System: {self.current_system['id']} ===")
        print(f"System Type: {self.current_system['type']}")
        print(f"Operating System: {self.current_system['os']}")
        print(f"Security Level: {self.current_system['security_level']}/10")
        print(f"Firewall: {'Yes' if self.current_system['firewall'] else 'No'}")
        print(f"IDS: {'Yes' if self.current_system['ids'] else 'No'}")
        print(f"Open Ports: {self.current_system['open_ports']}")
        print(f"Services: {self.current_system['services']}")
        print(f"Has Vulnerabilities: {'Yes' if self.current_system['has_vulnerability'] else 'No'}")
        
        if self.current_system['has_vulnerability']:
            print(f"Vulnerability Type: {self.current_system['vulnerability']['type']}")
            print(f"Vulnerability Severity: {self.current_system['vulnerability']['severity']}/10")
        
        print(f"\n=== Progress ===")
        print(f"Steps: {self.steps_taken}")
        print(f"Discovered Ports: {self.discovered_ports}")
        print(f"Discovered Services: {self.discovered_services}")
        print(f"Found Vulnerabilities: {self.found_vulnerabilities}")
        print(f"Access Level: {self.access_level}/2")
        
        # عرض مقاييس الدقة
        metrics = self.get_accuracy_metrics()
        print(f"\n=== Accuracy Metrics ===")
        print(f"Accuracy: {metrics['accuracy']:.2%}")
        print(f"Precision: {metrics['precision']:.2%}")
        print(f"Recall: {metrics['recall']:.2%}")
        print(f"F1 Score: {metrics['f1_score']:.2%}")
        print(f"True Positives: {metrics['true_positives']}")
        print(f"False Positives: {metrics['false_positives']}")
        print("="*50)

# ====================== الشبكات العصبية ======================
class ActorNetwork(nn.Module):
    def __init__(self, state_size, action_size, hidden_size=256):
        super(ActorNetwork, self).__init__()
        
        self.network = nn.Sequential(
            nn.Linear(state_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, action_size),
            nn.Softmax(dim=-1)
        )
    
    def forward(self, state):
        return self.network(state)

class CriticNetwork(nn.Module):
    def __init__(self, state_size, hidden_size=256):
        super(CriticNetwork, self).__init__()
        
        self.network = nn.Sequential(
            nn.Linear(state_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, 1)
        )
    
    def forward(self, state):
        return self.network(state)

# ====================== الذاكرة ======================
class ReplayMemory:
    def __init__(self, capacity):
        self.capacity = capacity
        self.memory = deque(maxlen=capacity)
    
    def push(self, state, action, reward, next_state, done):
        self.memory.append((state, action, reward, next_state, done))
    
    def sample(self, batch_size):
        if len(self.memory) < batch_size:
            return None
        
        batch = random.sample(self.memory, batch_size)
        states, actions, rewards, next_states, dones = zip(*batch)
        
        return (
            torch.FloatTensor(states),
            torch.LongTensor(actions),
            torch.FloatTensor(rewards),
            torch.FloatTensor(next_states),
            torch.FloatTensor(dones)
        )
    
    def __len__(self):
        return len(self.memory)

# ====================== وكيل التعلم المعزز ======================
class RLAgent:
    def __init__(self, state_size, action_size, config):
        self.state_size = state_size
        self.action_size = action_size
        self.config = config
        
        # الشبكات
        self.actor = ActorNetwork(state_size, action_size, config.hidden_size)
        self.critic = CriticNetwork(state_size, config.hidden_size)
        
        # المثيلات المستهدفة
        self.target_actor = ActorNetwork(state_size, action_size, config.hidden_size)
        self.target_critic = CriticNetwork(state_size, config.hidden_size)
        
        # نسخ الأوزان
        self.target_actor.load_state_dict(self.actor.state_dict())
        self.target_critic.load_state_dict(self.critic.state_dict())
        
        # المحسنات
        self.actor_optimizer = optim.Adam(self.actor.parameters(), lr=config.learning_rate)
        self.critic_optimizer = optim.Adam(self.critic.parameters(), lr=config.learning_rate)
        
        # الذاكرة
        self.memory = ReplayMemory(config.memory_size)
        
        # إحصائيات
        self.epsilon = config.epsilon_start
        self.steps = 0
        self.episodes = 0
        
        # نقل للنظام إذا كان متاحاً
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.actor.to(self.device)
        self.critic.to(self.device)
        self.target_actor.to(self.device)
        self.target_critic.to(self.device)
        
        # مقاييس الأداء
        self.accuracy_history = []
        self.precision_history = []
        self.recall_history = []
        self.f1_history = []
    
    def select_action(self, state, training=True):
        state_tensor = torch.FloatTensor(state).unsqueeze(0).to(self.device)
        
        if training and random.random() < self.epsilon:
            # استكشاف عشوائي
            action = random.randrange(self.action_size)
        else:
            # استغلال
            with torch.no_grad():
                action_probs = self.actor(state_tensor)
                action_dist = Categorical(action_probs)
                action = action_dist.sample().item()
        
        # تخفيض إبسيلون
        if training:
            self.epsilon = max(self.config.epsilon_end, 
                             self.epsilon * self.config.epsilon_decay)
        
        return action
    
    def learn(self):
        if len(self.memory) < self.config.batch_size:
            return 0, 0
        
        # أخذ عينة من الذاكرة
        batch = self.memory.sample(self.config.batch_size)
        if batch is None:
            return 0, 0
        
        states, actions, rewards, next_states, dones = batch
        
        states = states.to(self.device)
        actions = actions.to(self.device)
        rewards = rewards.to(self.device)
        next_states = next_states.to(self.device)
        dones = dones.to(self.device)
        
        # حساب قيم Q المستهدفة
        with torch.no_grad():
            next_action_probs = self.target_actor(next_states)
            next_action_dist = Categorical(next_action_probs)
            next_actions = next_action_dist.sample()
            next_q_values = self.target_critic(next_states).squeeze()
            
            target_q_values = rewards + self.config.gamma * next_q_values * (1 - dones)
        
        # تحديث الناقد
        current_q_values = self.critic(states).squeeze()
        critic_loss = F.mse_loss(current_q_values, target_q_values)
        
        self.critic_optimizer.zero_grad()
        critic_loss.backward()
        torch.nn.utils.clip_grad_norm_(self.critic.parameters(), 1.0)
        self.critic_optimizer.step()
        
        # تحديث الممثل
        action_probs = self.actor(states)
        action_dist = Categorical(action_probs)
        action_log_probs = action_dist.log_prob(actions)
        
        actor_loss = -torch.mean(action_log_probs * (target_q_values - current_q_values.detach()))
        
        self.actor_optimizer.zero_grad()
        actor_loss.backward()
        torch.nn.utils.clip_grad_norm_(self.actor.parameters(), 1.0)
        self.actor_optimizer.step()
        
        # تحديث الشبكات المستهدفة
        self._soft_update(self.target_actor, self.actor, self.config.tau)
        self._soft_update(self.target_critic, self.critic, self.config.tau)
        
        return actor_loss.item(), critic_loss.item()
    
    def _soft_update(self, target, source, tau):
        for target_param, param in zip(target.parameters(), source.parameters()):
            target_param.data.copy_(tau * param.data + (1.0 - tau) * target_param.data)
    
    def update_accuracy_metrics(self, accuracy, precision, recall, f1):
        """تحديث مقاييس الدقة"""
        self.accuracy_history.append(accuracy)
        self.precision_history.append(precision)
        self.recall_history.append(recall)
        self.f1_history.append(f1)
    
    def get_accuracy_metrics(self):
        """الحصول على مقاييس الدقة"""
        if len(self.accuracy_history) == 0:
            return {
                'accuracy': 0,
                'precision': 0,
                'recall': 0,
                'f1_score': 0
            }
        
        return {
            'accuracy': np.mean(self.accuracy_history[-self.config.metrics_window:]),
            'precision': np.mean(self.precision_history[-self.config.metrics_window:]),
            'recall': np.mean(self.recall_history[-self.config.metrics_window:]),
            'f1_score': np.mean(self.f1_history[-self.config.metrics_window:])
        }
    
    def save_model(self, path):
        torch.save({
            'actor_state_dict': self.actor.state_dict(),
            'critic_state_dict': self.critic.state_dict(),
            'actor_optimizer_state_dict': self.actor_optimizer.state_dict(),
            'critic_optimizer_state_dict': self.critic_optimizer.state_dict(),
            'epsilon': self.epsilon,
            'steps': self.steps,
            'episodes': self.episodes,
            'accuracy_history': self.accuracy_history,
            'precision_history': self.precision_history,
            'recall_history': self.recall_history,
            'f1_history': self.f1_history
        }, path)
    
    def load_model(self, path):
        checkpoint = torch.load(path)
        self.actor.load_state_dict(checkpoint['actor_state_dict'])
        self.critic.load_state_dict(checkpoint['critic_state_dict'])
        self.actor_optimizer.load_state_dict(checkpoint['actor_optimizer_state_dict'])
        self.critic_optimizer.load_state_dict(checkpoint['critic_optimizer_state_dict'])
        self.epsilon = checkpoint['epsilon']
        self.steps = checkpoint['steps']
        self.episodes = checkpoint['episodes']
        
        # تحميل مقاييس الدقة إذا كانت موجودة
        if 'accuracy_history' in checkpoint:
            self.accuracy_history = checkpoint['accuracy_history']
        if 'precision_history' in checkpoint:
            self.precision_history = checkpoint['precision_history']
        if 'recall_history' in checkpoint:
            self.recall_history = checkpoint['recall_history']
        if 'f1_history' in checkpoint:
            self.f1_history = checkpoint['f1_history']
        
        # تحديث الشبكات المستهدفة
        self.target_actor.load_state_dict(self.actor.state_dict())
        self.target_critic.load_state_dict(self.critic.state_dict())

# ====================== النظام الذاتي التعلم ======================
class AutonomousLearningSystem:
    def __init__(self):
        self.config = SystemConfig()
        self.data_generator = DataGenerator()
        self.env = VulnerabilityEnv(self.data_generator)
        
        state_size = self.env.observation_space.shape[0]
        action_size = self.env.action_space.n
        
        self.agent = RLAgent(state_size, action_size, self.config)
        
        # إحصائيات التدريب
        self.training_stats = {
            'episode_rewards': [],
            'episode_lengths': [],
            'losses': [],
            'epsilon_values': [],
            'success_rate': [],
            'accuracy_history': [],
            'precision_history': [],
            'recall_history': [],
            'f1_history': []
        }
        
        # إنشاء سجل
        self.setup_logging()
    
    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/training.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def train(self, num_episodes=None):
        if num_episodes is None:
            num_episodes = self.config.max_episodes
        
        self.logger.info(f"بدء التدريب لـ {num_episodes} حلقة")
        
        for episode in range(num_episodes):
            state = self.env.reset()
            episode_reward = 0
            episode_loss = 0
            steps = 0
            
            # مقاييس الدقة للحلقة
            episode_true_labels = []
            episode_predicted_labels = []
            vulnerability_detected = False
            
            for step in range(self.config.max_steps):
                # اختيار إجراء
                action = self.agent.select_action(state, training=True)
                
                # تنفيذ الإجراء
                next_state, reward, done, info = self.env.step(action)
                
                # حفظ الخبرة
                self.agent.memory.push(state, action, reward, next_state, done)
                
                # التعلم
                actor_loss, critic_loss = self.agent.learn()
                if actor_loss > 0:
                    episode_loss += actor_loss + critic_loss
                
                # تحديث الحالة
                state = next_state
                episode_reward += reward
                steps += 1
                self.agent.steps += 1
                
                # جمع بيانات للدقة
                if action in [3, 4, 5, 6, 7]:  # اختبارات الثغرات
                    vuln_types = ['SQL Injection', 'XSS', 'RCE', 'LFI', 'SSRF']
                    test_vuln = vuln_types[action-3]
                    
                    # التسمية الحقيقية
                    true_label = 1 if (self.env.current_system['has_vulnerability'] and 
                                     self.env.current_system['vulnerability']['type'] == test_vuln) else 0
                    
                    # التسمية المتوقعة (نفترض أن الاختبار صحيح إذا أعطى مكافأة موجبة)
                    predicted_label = 1 if reward > 0 else 0
                    
                    episode_true_labels.append(true_label)
                    episode_predicted_labels.append(predicted_label)
                
                if info.get('vulnerabilities_found', 0) > 0:
                    vulnerability_detected = True
                
                if done:
                    break
            
            # حساب مقاييس الدقة للحلقة
            accuracy_metrics = self.data_generator.update_metrics(
                episode_true_labels, 
                episode_predicted_labels,
                vulnerability_detected
            )
            
            # تحديث مقاييس الدقة لدى الوكيل
            self.agent.update_accuracy_metrics(
                accuracy_metrics['accuracy'],
                accuracy_metrics['precision'],
                accuracy_metrics['recall'],
                accuracy_metrics['f1_score']
            )
            
            # تحديث الإحصائيات
            self.training_stats['episode_rewards'].append(episode_reward)
            self.training_stats['episode_lengths'].append(steps)
            self.training_stats['epsilon_values'].append(self.agent.epsilon)
            self.training_stats['losses'].append(episode_loss / max(steps, 1))
            self.training_stats['accuracy_history'].append(accuracy_metrics['accuracy'])
            self.training_stats['precision_history'].append(accuracy_metrics['precision'])
            self.training_stats['recall_history'].append(accuracy_metrics['recall'])
            self.training_stats['f1_history'].append(accuracy_metrics['f1_score'])
            
            # حساب معدل النجاح
            success = 1 if episode_reward > 10 else 0
            if len(self.training_stats['success_rate']) < 10:
                self.training_stats['success_rate'].append(success)
            else:
                self.training_stats['success_rate'].pop(0)
                self.training_stats['success_rate'].append(success)
            
            self.agent.episodes += 1
            
            # عرض التقدم
            if (episode + 1) % 10 == 0:
                avg_reward = np.mean(self.training_stats['episode_rewards'][-10:])
                avg_steps = np.mean(self.training_stats['episode_lengths'][-10:])
                success_rate = np.mean(self.training_stats['success_rate']) * 100
                
                # الحصول على مقاييس الدقة
                accuracy_metrics = self.agent.get_accuracy_metrics()
                
                self.logger.info(
                    f"Episode {episode + 1:4d} | "
                    f"Avg Reward: {avg_reward:6.2f} | "
                    f"Avg Steps: {avg_steps:5.1f} | "
                    f"Success Rate: {success_rate:5.1f}% | "
                    f"Accuracy: {accuracy_metrics['accuracy']:.3f} | "
                    f"F1 Score: {accuracy_metrics['f1_score']:.3f} | "
                    f"Epsilon: {self.agent.epsilon:.3f}"
                )
            
            # حفظ النموذج
            if (episode + 1) % self.config.save_every == 0:
                model_path = f"models/agent_episode_{episode + 1}.pth"
                self.agent.save_model(model_path)
                self.data_generator.save_patterns()
                self.save_training_stats()
                
                self.logger.info(f"Model saved to {model_path}")
        
        # حفظ النموذج النهائي
        final_path = "models/agent_final.pth"
        self.agent.save_model(final_path)
        self.data_generator.save_patterns()
        self.save_training_stats()
        self.plot_training_results()
        self.plot_accuracy_metrics()
        
        self.logger.info(f"Training completed! Final model saved to {final_path}")
        
        # عرض ملخص الأداء النهائي
        self.print_final_metrics()
    
    def print_final_metrics(self):
        """طباعة المقاييس النهائية"""
        print("\n" + "="*60)
        print("FINAL PERFORMANCE METRICS")
        print("="*60)
        
        # حساب المتوسطات
        avg_reward = np.mean(self.training_stats['episode_rewards'][-100:]) if len(self.training_stats['episode_rewards']) >= 100 else np.mean(self.training_stats['episode_rewards'])
        avg_accuracy = np.mean(self.training_stats['accuracy_history'][-100:]) if len(self.training_stats['accuracy_history']) >= 100 else np.mean(self.training_stats['accuracy_history'])
        avg_precision = np.mean(self.training_stats['precision_history'][-100:]) if len(self.training_stats['precision_history']) >= 100 else np.mean(self.training_stats['precision_history'])
        avg_recall = np.mean(self.training_stats['recall_history'][-100:]) if len(self.training_stats['recall_history']) >= 100 else np.mean(self.training_stats['recall_history'])
        avg_f1 = np.mean(self.training_stats['f1_history'][-100:]) if len(self.training_stats['f1_history']) >= 100 else np.mean(self.training_stats['f1_history'])
        
        print(f"Average Reward (last 100 episodes): {avg_reward:.2f}")
        print(f"Average Accuracy: {avg_accuracy:.3f}")
        print(f"Average Precision: {avg_precision:.3f}")
        print(f"Average Recall: {avg_recall:.3f}")
        print(f"Average F1 Score: {avg_f1:.3f}")
        print(f"Total Episodes: {self.agent.episodes}")
        print(f"Total Steps: {self.agent.steps}")
        print("="*60)
    
    def test(self, num_episodes=100, render=False):
        self.logger.info(f"Starting test for {num_episodes} episodes")
        
        test_stats = {
            'rewards': [],
            'steps': [],
            'vulnerabilities_found': [],
            'access_levels': [],
            'successful_episodes': 0,
            'accuracy_scores': [],
            'precision_scores': [],
            'recall_scores': [],
            'f1_scores': [],
            'confusion_matrices': []
        }
        
        for episode in range(num_episodes):
            state = self.env.reset()
            episode_reward = 0
            steps = 0
            max_access = 0
            vulnerabilities_found = 0
            
            # مقاييس الدقة
            episode_true_labels = []
            episode_predicted_labels = []
            
            for step in range(self.config.max_steps):
                # اختيار إجراء (بدون استكشاف)
                action = self.agent.select_action(state, training=False)
                
                # تنفيذ الإجراء
                next_state, reward, done, info = self.env.step(action)
                
                # تحديث الإحصائيات
                episode_reward += reward
                steps += 1
                max_access = max(max_access, info['access_level'])
                vulnerabilities_found = max(vulnerabilities_found, info['vulnerabilities_found'])
                
                # جمع بيانات للدقة
                if action in [3, 4, 5, 6, 7]:  # اختبارات الثغرات
                    vuln_types = ['SQL Injection', 'XSS', 'RCE', 'LFI', 'SSRF']
                    test_vuln = vuln_types[action-3]
                    
                    # التسمية الحقيقية
                    true_label = 1 if (self.env.current_system['has_vulnerability'] and 
                                     self.env.current_system['vulnerability']['type'] == test_vuln) else 0
                    
                    # التسمية المتوقعة (نفترض أن الاختبار صحيح إذا أعطى مكافأة موجبة)
                    predicted_label = 1 if reward > 0 else 0
                    
                    episode_true_labels.append(true_label)
                    episode_predicted_labels.append(predicted_label)
                
                if render:
                    self.env.render()
                    print(f"Action: {info['action']}")
                    print(f"Reward: {reward:.2f}")
                    time.sleep(0.1)
                
                if done:
                    break
            
            # تحديث إحصائيات الاختبار
            test_stats['rewards'].append(episode_reward)
            test_stats['steps'].append(steps)
            test_stats['vulnerabilities_found'].append(vulnerabilities_found)
            test_stats['access_levels'].append(max_access)
            
            if episode_reward > 15:  # عتبة النجاح
                test_stats['successful_episodes'] += 1
            
            # حساب مقاييس الدقة
            if episode_true_labels:
                accuracy, precision, recall, f1 = self.data_generator.calculate_accuracy_metrics(
                    episode_true_labels, episode_predicted_labels
                )
                test_stats['accuracy_scores'].append(accuracy)
                test_stats['precision_scores'].append(precision)
                test_stats['recall_scores'].append(recall)
                test_stats['f1_scores'].append(f1)
        
        # عرض نتائج الاختبار
        print("\n" + "="*60)
        print("TEST RESULTS")
        print("="*60)
        print(f"Total Episodes: {num_episodes}")
        print(f"Average Reward: {np.mean(test_stats['rewards']):.2f}")
        print(f"Average Steps: {np.mean(test_stats['steps']):.2f}")
        print(f"Average Vulnerabilities Found: {np.mean(test_stats['vulnerabilities_found']):.2f}")
        print(f"Average Access Level: {np.mean(test_stats['access_levels']):.2f}")
        print(f"Successful Episodes: {test_stats['successful_episodes']} ({test_stats['successful_episodes']/num_episodes*100:.1f}%)")
        
        # عرض مقاييس الدقة
        if test_stats['accuracy_scores']:
            print(f"\nAccuracy Metrics:")
            print(f"  Average Accuracy: {np.mean(test_stats['accuracy_scores']):.3f}")
            print(f"  Average Precision: {np.mean(test_stats['precision_scores']):.3f}")
            print(f"  Average Recall: {np.mean(test_stats['recall_scores']):.3f}")
            print(f"  Average F1 Score: {np.mean(test_stats['f1_scores']):.3f}")
        
        print("="*60)
        
        # حفظ نتائج الاختبار
        self.save_test_results(test_stats, num_episodes)
        
        return test_stats
    
    def save_test_results(self, test_stats, num_episodes):
        """حفظ نتائج الاختبار"""
        with open('reports/test_results.txt', 'w') as f:
            f.write("Vulnerability Detection System - Test Results\n")
            f.write("="*50 + "\n")
            f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total Episodes: {num_episodes}\n")
            f.write(f"Average Reward: {np.mean(test_stats['rewards']):.2f}\n")
            f.write(f"Average Steps: {np.mean(test_stats['steps']):.2f}\n")
            f.write(f"Average Vulnerabilities: {np.mean(test_stats['vulnerabilities_found']):.2f}\n")
            f.write(f"Success Rate: {test_stats['successful_episodes']/num_episodes*100:.1f}%\n")
            
            if test_stats['accuracy_scores']:
                f.write(f"\nAccuracy Metrics:\n")
                f.write(f"  Average Accuracy: {np.mean(test_stats['accuracy_scores']):.3f}\n")
                f.write(f"  Average Precision: {np.mean(test_stats['precision_scores']):.3f}\n")
                f.write(f"  Average Recall: {np.mean(test_stats['recall_scores']):.3f}\n")
                f.write(f"  Average F1 Score: {np.mean(test_stats['f1_scores']):.3f}\n")
    
    def save_training_stats(self):
        stats = {
            'training_stats': self.training_stats,
            'config': self.config.__dict__,
            'timestamp': datetime.now().isoformat()
        }
        
        with open('data/training_stats.pkl', 'wb') as f:
            pickle.dump(stats, f)
    
    def load_training_stats(self):
        if os.path.exists('data/training_stats.pkl'):
            with open('data/training_stats.pkl', 'rb') as f:
                stats = pickle.load(f)
                self.training_stats = stats['training_stats']
    
    def plot_training_results(self):
        """رسم نتائج التدريب باللغة الإنجليزية"""
        fig, axes = plt.subplots(3, 3, figsize=(15, 12))
        
        # 1. Reward Evolution
        axes[0, 0].plot(self.training_stats['episode_rewards'], alpha=0.6, linewidth=0.8)
        axes[0, 0].set_title('Reward per Episode', fontsize=12, fontweight='bold')
        axes[0, 0].set_xlabel('Episode')
        axes[0, 0].set_ylabel('Reward')
        axes[0, 0].grid(True, alpha=0.3)
        
        # Moving average
        window_size = 50
        if len(self.training_stats['episode_rewards']) >= window_size:
            moving_avg = pd.Series(self.training_stats['episode_rewards']).rolling(window_size).mean()
            axes[0, 0].plot(moving_avg, 'r', linewidth=2, label=f'{window_size}-episode MA')
            axes[0, 0].legend()
        
        # 2. Episode Length
        axes[0, 1].plot(self.training_stats['episode_lengths'], alpha=0.6, linewidth=0.8, color='green')
        axes[0, 1].set_title('Episode Length', fontsize=12, fontweight='bold')
        axes[0, 1].set_xlabel('Episode')
        axes[0, 1].set_ylabel('Steps')
        axes[0, 1].grid(True, alpha=0.3)
        
        # 3. Success Rate
        if self.training_stats['success_rate']:
            success_rates = []
            for i in range(len(self.training_stats['success_rate'])):
                if i >= 9:
                    avg = np.mean(self.training_stats['success_rate'][i-9:i+1]) * 100
                    success_rates.append(avg)
            
            axes[0, 2].plot(success_rates, alpha=0.8, linewidth=1.5, color='purple')
            axes[0, 2].set_title('Success Rate (10-episode moving avg)', fontsize=12, fontweight='bold')
            axes[0, 2].set_xlabel('Episode')
            axes[0, 2].set_ylabel('Success Rate (%)')
            axes[0, 2].grid(True, alpha=0.3)
        
        # 4. Loss Evolution
        axes[1, 0].plot(self.training_stats['losses'], alpha=0.6, linewidth=0.8, color='red')
        axes[1, 0].set_title('Training Loss', fontsize=12, fontweight='bold')
        axes[1, 0].set_xlabel('Episode')
        axes[1, 0].set_ylabel('Loss')
        axes[1, 0].grid(True, alpha=0.3)
        
        # 5. Epsilon Decay
        axes[1, 1].plot(self.training_stats['epsilon_values'], alpha=0.8, linewidth=1.5, color='orange')
        axes[1, 1].set_title('Epsilon Decay', fontsize=12, fontweight='bold')
        axes[1, 1].set_xlabel('Episode')
        axes[1, 1].set_ylabel('Epsilon')
        axes[1, 1].grid(True, alpha=0.3)
        
        # 6. Accuracy History
        if self.training_stats['accuracy_history']:
            axes[1, 2].plot(self.training_stats['accuracy_history'], alpha=0.8, linewidth=1.5, color='blue')
            axes[1, 2].set_title('Detection Accuracy', fontsize=12, fontweight='bold')
            axes[1, 2].set_xlabel('Episode')
            axes[1, 2].set_ylabel('Accuracy')
            axes[1, 2].grid(True, alpha=0.3)
            
            # Moving average for accuracy
            if len(self.training_stats['accuracy_history']) >= 50:
                accuracy_ma = pd.Series(self.training_stats['accuracy_history']).rolling(50).mean()
                axes[1, 2].plot(accuracy_ma, 'r', linewidth=2, label='50-episode MA')
                axes[1, 2].legend()
        
        # 7. F1 Score History
        if self.training_stats['f1_history']:
            axes[2, 0].plot(self.training_stats['f1_history'], alpha=0.8, linewidth=1.5, color='green')
            axes[2, 0].set_title('F1 Score Evolution', fontsize=12, fontweight='bold')
            axes[2, 0].set_xlabel('Episode')
            axes[2, 0].set_ylabel('F1 Score')
            axes[2, 0].grid(True, alpha=0.3)
        
        # 8. Reward Distribution
        axes[2, 1].hist(self.training_stats['episode_rewards'], bins=30, edgecolor='black', alpha=0.7, color='skyblue')
        axes[2, 1].set_title('Reward Distribution', fontsize=12, fontweight='bold')
        axes[2, 1].set_xlabel('Reward')
        axes[2, 1].set_ylabel('Frequency')
        axes[2, 1].grid(True, alpha=0.3)
        
        # 9. Correlation: Reward vs Accuracy
        if self.training_stats['accuracy_history']:
            min_len = min(len(self.training_stats['episode_rewards']), len(self.training_stats['accuracy_history']))
            rewards = self.training_stats['episode_rewards'][:min_len]
            accuracy = self.training_stats['accuracy_history'][:min_len]
            
            axes[2, 2].scatter(rewards, accuracy, alpha=0.5, c='purple')
            axes[2, 2].set_title('Reward vs Accuracy Correlation', fontsize=12, fontweight='bold')
            axes[2, 2].set_xlabel('Reward')
            axes[2, 2].set_ylabel('Accuracy')
            axes[2, 2].grid(True, alpha=0.3)
            
            # Add trend line
            if len(rewards) > 1:
                z = np.polyfit(rewards, accuracy, 1)
                p = np.poly1d(z)
                axes[2, 2].plot(sorted(rewards), p(sorted(rewards)), "r--", alpha=0.8)
        
        plt.suptitle('Vulnerability Detection System - Training Performance', 
                    fontsize=16, fontweight='bold', y=1.02)
        plt.tight_layout()
        plt.savefig('plots/training_performance.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return fig
    
    def plot_accuracy_metrics(self):
        """رسم مقاييس الدقة"""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # 1. Accuracy Over Time
        axes[0, 0].plot(self.training_stats['accuracy_history'], color='blue', linewidth=2)
        axes[0, 0].set_title('Accuracy Over Time', fontsize=14, fontweight='bold')
        axes[0, 0].set_xlabel('Episode')
        axes[0, 0].set_ylabel('Accuracy')
        axes[0, 0].grid(True, alpha=0.3)
        
        if len(self.training_stats['accuracy_history']) >= 50:
            accuracy_ma = pd.Series(self.training_stats['accuracy_history']).rolling(50).mean()
            axes[0, 0].plot(accuracy_ma, 'r', linewidth=2, label='50-episode MA')
            axes[0, 0].legend()
        
        # 2. Precision-Recall Curve
        if self.training_stats['precision_history'] and self.training_stats['recall_history']:
            axes[0, 1].plot(self.training_stats['recall_history'], self.training_stats['precision_history'], 
                           color='green', linewidth=2, marker='o', markersize=3)
            axes[0, 1].set_title('Precision-Recall Curve', fontsize=14, fontweight='bold')
            axes[0, 1].set_xlabel('Recall')
            axes[0, 1].set_ylabel('Precision')
            axes[0, 1].grid(True, alpha=0.3)
        
        # 3. F1 Score Evolution
        if self.training_stats['f1_history']:
            axes[1, 0].plot(self.training_stats['f1_history'], color='purple', linewidth=2)
            axes[1, 0].set_title('F1 Score Evolution', fontsize=14, fontweight='bold')
            axes[1, 0].set_xlabel('Episode')
            axes[1, 0].set_ylabel('F1 Score')
            axes[1, 0].grid(True, alpha=0.3)
            
            if len(self.training_stats['f1_history']) >= 50:
                f1_ma = pd.Series(self.training_stats['f1_history']).rolling(50).mean()
                axes[1, 0].plot(f1_ma, 'r', linewidth=2, label='50-episode MA')
                axes[1, 0].legend()
        
        # 4. Metric Comparison Bar Chart
        metrics = ['Accuracy', 'Precision', 'Recall', 'F1']
        if (self.training_stats['accuracy_history'] and self.training_stats['precision_history'] and 
            self.training_stats['recall_history'] and self.training_stats['f1_history']):
            
            avg_values = [
                np.mean(self.training_stats['accuracy_history'][-100:]),
                np.mean(self.training_stats['precision_history'][-100:]),
                np.mean(self.training_stats['recall_history'][-100:]),
                np.mean(self.training_stats['f1_history'][-100:])
            ]
            
            colors = ['blue', 'green', 'orange', 'purple']
            bars = axes[1, 1].bar(metrics, avg_values, color=colors, alpha=0.7)
            axes[1, 1].set_title('Average Metrics (last 100 episodes)', fontsize=14, fontweight='bold')
            axes[1, 1].set_ylabel('Score')
            axes[1, 1].grid(True, alpha=0.3, axis='y')
            
            # Add value labels on bars
            for bar, value in zip(bars, avg_values):
                height = bar.get_height()
                axes[1, 1].text(bar.get_x() + bar.get_width()/2., height,
                               f'{value:.3f}', ha='center', va='bottom')
        
        plt.suptitle('Vulnerability Detection Accuracy Metrics', fontsize=16, fontweight='bold', y=1.02)
        plt.tight_layout()
        plt.savefig('plots/accuracy_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return fig

# ====================== واجهة المستخدم ======================
class UserInterface:
    def __init__(self):
        self.system = None
        self.model_loaded = False
    
    def show_menu(self):
        print("\n" + "="*60)
        print("AUTONOMOUS VULNERABILITY DETECTION SYSTEM")
        print("="*60)
        print("1. Train from Scratch")
        print("2. Resume Training")
        print("3. Test Trained Model")
        print("4. Interactive Demo")
        print("5. Analyze Data and Metrics")
        print("6. Create Backup")
        print("7. Load Trained Model")
        print("8. Exit")
        print("="*60)
    
    def run(self):
        while True:
            self.show_menu()
            choice = input("\nSelect option (1-8): ").strip()
            
            try:
                if choice == '1':
                    self.train_from_scratch()
                elif choice == '2':
                    self.resume_training()
                elif choice == '3':
                    self.test_model()
                elif choice == '4':
                    self.run_demo()
                elif choice == '5':
                    self.analyze_data()
                elif choice == '6':
                    self.create_backup()
                elif choice == '7':
                    self.load_model()
                elif choice == '8':
                    print("\nThank you for using the Autonomous Learning System! 👋")
                    break
                else:
                    print("⚠️ Invalid choice, please try again")
            
            except KeyboardInterrupt:
                print("\n\nSystem stopped by user")
                break
            except Exception as e:
                print(f"\n❌ Error occurred: {str(e)}")
                print("Please try again")
    
    def train_from_scratch(self):
        print("\n🎯 Starting Training from Scratch")
        episodes = input("Training episodes (default: 1000): ").strip()
        
        try:
            num_episodes = int(episodes) if episodes else 1000
        except:
            num_episodes = 1000
        
        confirm = input(f"\nStart training for {num_episodes} episodes? (yes/no): ").strip().lower()
        
        if confirm in ['yes', 'y', '1']:
            self.system = AutonomousLearningSystem()
            print(f"\n⏳ Starting training for {num_episodes} episodes...")
            print("This may take some time...")
            
            start_time = time.time()
            self.system.train(num_episodes)
            end_time = time.time()
            
            duration = end_time - start_time
            hours = int(duration // 3600)
            minutes = int((duration % 3600) // 60)
            seconds = int(duration % 60)
            
            print(f"\n✅ Training completed in {hours:02d}:{minutes:02d}:{seconds:02d}")
            self.model_loaded = True
        else:
            print("❌ Training cancelled")
    
    def resume_training(self):
        model_path = input("\nModel path to resume (default: models/agent_final.pth): ").strip()
        if not model_path:
            model_path = "models/agent_final.pth"
        
        if not os.path.exists(model_path):
            print(f"❌ Model file not found: {model_path}")
            return
        
        episodes = input("Additional training episodes (default: 500): ").strip()
        
        try:
            num_episodes = int(episodes) if episodes else 500
        except:
            num_episodes = 500
        
        confirm = input(f"\nResume training for {num_episodes} additional episodes? (yes/no): ").strip().lower()
        
        if confirm in ['yes', 'y', '1']:
            self.system = AutonomousLearningSystem()
            
            # تحميل النموذج
            if os.path.exists(model_path):
                self.system.agent.load_model(model_path)
                self.system.load_training_stats()
                print(f"✅ Model loaded from {model_path}")
            
            print(f"\n⏳ Resuming training for {num_episodes} additional episodes...")
            
            start_time = time.time()
            self.system.train(num_episodes)
            end_time = time.time()
            
            duration = end_time - start_time
            hours = int(duration // 3600)
            minutes = int((duration % 3600) // 60)
            seconds = int(duration % 60)
            
            print(f"\n✅ Training completed in {hours:02d}:{minutes:02d}:{seconds:02d}")
            self.model_loaded = True
        else:
            print("❌ Training cancelled")
    
    def test_model(self):
        if not self.model_loaded:
            self.load_model()
            if not self.model_loaded:
                return
        
        episodes = input("\nTest episodes (default: 100): ").strip()
        
        try:
            num_episodes = int(episodes) if episodes else 100
        except:
            num_episodes = 100
        
        render = input("Show details during testing? (yes/no): ").strip().lower()
        render_mode = render in ['yes', 'y', '1']
        
        print(f"\n🔬 Starting model test for {num_episodes} episodes...")
        
        start_time = time.time()
        results = self.system.test(num_episodes, render_mode)
        end_time = time.time()
        
        duration = end_time - start_time
        minutes = int(duration // 60)
        seconds = int(duration % 60)
        
        print(f"\n⏱️  Test duration: {minutes:02d}:{seconds:02d}")
        
        # Display accuracy metrics
        if results['accuracy_scores']:
            print("\n📊 Detailed Accuracy Metrics:")
            print(f"  Highest accuracy: {np.max(results['accuracy_scores']):.3f}")
            print(f"  Lowest accuracy: {np.min(results['accuracy_scores']):.3f}")
            print(f"  Standard deviation: {np.std(results['accuracy_scores']):.3f}")
            print(f"  Highest F1 score: {np.max(results['f1_scores']):.3f}")
    
    def run_demo(self):
        print("\n🎮 Starting Interactive Demo")
        print("The system will show 5 episodes of interaction with different systems")
        
        if not self.model_loaded:
            print("⚠️ Loading default model...")
            self.system = AutonomousLearningSystem()
            self.model_loaded = True
        
        for demo_num in range(5):
            print(f"\n{'='*60}")
            print(f"Demo {demo_num + 1}/5")
            print(f"{'='*60}")
            
            state = self.system.env.reset()
            total_reward = 0
            step = 0
            
            self.system.env.render()
            
            for _ in range(20):  # Maximum 20 steps for demo
                action = self.system.agent.select_action(state, training=False)
                next_state, reward, done, info = self.system.env.step(action)
                
                print(f"\nStep {step + 1}:")
                print(f"  Action: {info['action']}")
                print(f"  Reward: {reward:.2f}")
                print(f"  Vulnerabilities found: {info['vulnerabilities_found']}")
                print(f"  Access level: {info['access_level']}")
                
                state = next_state
                total_reward += reward
                step += 1
                
                time.sleep(0.5)
                
                if done:
                    break
            
            print(f"\nDemo {demo_num + 1} Results:")
            print(f"  Total Reward: {total_reward:.2f}")
            print(f"  Total Steps: {step}")
            
            if demo_num < 4:
                input("\n↵ Press Enter to continue to next demo...")
        
        print(f"\n{'='*60}")
        print("Demo completed!")
        print(f"{'='*60}")
    
    def analyze_data(self):
        print("\n📈 Data and Metrics Analysis")
        
        # Check available data
        data_files = []
        if os.path.exists('data/training_stats.pkl'):
            data_files.append('Training Statistics')
        if os.path.exists('data/patterns.json'):
            data_files.append('Learned Patterns')
        if os.path.exists('reports/test_results.txt'):
            data_files.append('Test Results')
        if os.path.exists('logs/training.log'):
            data_files.append('Training Log')
        if os.path.exists('plots/'):
            plot_files = os.listdir('plots/')
            if plot_files:
                data_files.append('Performance Plots')
        
        if not data_files:
            print("❌ No data available for analysis")
            return
        
        print("Available Data:")
        for i, file in enumerate(data_files, 1):
            print(f"  {i}. {file}")
        
        try:
            choice = input("\nSelect data type to analyze (number): ").strip()
            choice = int(choice) - 1
            
            if choice < 0 or choice >= len(data_files):
                print("❌ Invalid selection")
                return
            
            selected_file = data_files[choice]
            
            if selected_file == 'Training Statistics':
                self.analyze_training_stats()
            elif selected_file == 'Learned Patterns':
                self.analyze_patterns()
            elif selected_file == 'Test Results':
                self.analyze_test_results()
            elif selected_file == 'Training Log':
                self.analyze_training_log()
            elif selected_file == 'Performance Plots':
                self.show_performance_plots()
        
        except ValueError:
            print("❌ Please enter a valid number")
    
    def analyze_training_stats(self):
        if not os.path.exists('data/training_stats.pkl'):
            print("❌ Training statistics file not found")
            return
        
        with open('data/training_stats.pkl', 'rb') as f:
            stats = pickle.load(f)
        
        training_stats = stats['training_stats']
        
        print("\n📊 Training Statistics Analysis:")
        print(f"  Total episodes: {len(training_stats['episode_rewards'])}")
        print(f"  Average reward: {np.mean(training_stats['episode_rewards']):.2f}")
        print(f"  Best reward: {np.max(training_stats['episode_rewards']):.2f}")
        print(f"  Average episode length: {np.mean(training_stats['episode_lengths']):.2f}")
        
        if 'accuracy_history' in training_stats and training_stats['accuracy_history']:
            print(f"  Average accuracy: {np.mean(training_stats['accuracy_history']):.3f}")
            print(f"  Average F1 score: {np.mean(training_stats['f1_history']):.3f}")
        
        # Show plots if system is available
        if self.system:
            self.system.plot_training_results()
            self.system.plot_accuracy_metrics()
        else:
            print("⚠️ System needs to be loaded to display plots")
    
    def show_performance_plots(self):
        """عرض المخططات المحفوظة"""
        plot_files = [f for f in os.listdir('plots/') if f.endswith('.png')]
        
        if not plot_files:
            print("❌ No plot files found")
            return
        
        print("\n📊 Available Performance Plots:")
        for i, plot_file in enumerate(plot_files, 1):
            print(f"  {i}. {plot_file}")
        
        try:
            choice = input("\nSelect plot to display (number): ").strip()
            choice = int(choice) - 1
            
            if 0 <= choice < len(plot_files):
                plot_path = os.path.join('plots', plot_files[choice])
                
                # Display the plot
                img = plt.imread(plot_path)
                plt.figure(figsize=(10, 8))
                plt.imshow(img)
                plt.axis('off')
                plt.title(plot_files[choice], fontsize=14, fontweight='bold')
                plt.tight_layout()
                plt.show()
                
                print(f"\n✅ Displaying: {plot_files[choice]}")
            else:
                print("❌ Invalid selection")
        
        except Exception as e:
            print(f"❌ Error displaying plot: {str(e)}")
    
    def analyze_patterns(self):
        if not os.path.exists('data/patterns.json'):
            print("❌ Patterns file not found")
            return
        
        with open('data/patterns.json', 'r') as f:
            patterns = json.load(f)
        
        print(f"\n📚 Learned Patterns Analysis:")
        print(f"  Total patterns: {len(patterns)}")
        
        if patterns:
            # Analyze system distribution
            system_counts = {}
            vulnerability_counts = {}
            
            for pattern in patterns:
                system = pattern['system_type']
                vuln = pattern['vulnerability']
                
                system_counts[system] = system_counts.get(system, 0) + 1
                vulnerability_counts[vuln] = vulnerability_counts.get(vuln, 0) + 1
            
            print(f"\n  System Distribution:")
            for system, count in system_counts.items():
                percentage = (count / len(patterns)) * 100
                print(f"    • {system}: {count} ({percentage:.1f}%)")
            
            print(f"\n  Vulnerability Distribution:")
            for vuln, count in vulnerability_counts.items():
                percentage = (count / len(patterns)) * 100
                print(f"    • {vuln}: {count} ({percentage:.1f}%)")
    
    def analyze_test_results(self):
        if not os.path.exists('reports/test_results.txt'):
            print("❌ Test results file not found")
            return
        
        with open('reports/test_results.txt', 'r') as f:
            content = f.read()
        
        print("\n📋 Test Results:")
        print(content)
    
    def analyze_training_log(self):
        if not os.path.exists('logs/training.log'):
            print("❌ Training log file not found")
            return
        
        with open('logs/training.log', 'r') as f:
            lines = f.readlines()
        
        if not lines:
            print("❌ Training log is empty")
            return
        
        print(f"\n📝 Last 10 training log entries:")
        for line in lines[-10:]:
            print(f"  {line.strip()}")
    
    def create_backup(self):
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = f"backups/backup_{timestamp}"
        
        os.makedirs(backup_dir, exist_ok=True)
        
        # نسخ الملفات المهمة
        folders_to_backup = ['models', 'data', 'logs', 'reports', 'plots']
        
        print(f"\n💾 Creating backup in: {backup_dir}")
        
        for folder in folders_to_backup:
            if os.path.exists(folder):
                dest_folder = os.path.join(backup_dir, folder)
                shutil.copytree(folder, dest_folder)
                print(f"  ✅ Copied: {folder}")
        
        # إنشاء ملف معلومات النسخة الاحتياطية
        info = {
            'timestamp': timestamp,
            'date': datetime.now().isoformat(),
            'folders_backed_up': folders_to_backup,
            'system': 'Autonomous Vulnerability Detection System'
        }
        
        with open(os.path.join(backup_dir, 'backup_info.json'), 'w') as f:
            json.dump(info, f, indent=2)
        
        print(f"\n✅ Backup completed: {backup_dir}")
    
    def load_model(self):
        model_path = input("\nModel path to load (default: models/agent_final.pth): ").strip()
        if not model_path:
            model_path = "models/agent_final.pth"
        
        if not os.path.exists(model_path):
            print(f"❌ Model file not found: {model_path}")
            
            # عرض النماذج المتاحة
            model_files = [f for f in os.listdir('models') if f.endswith('.pth')]
            if model_files:
                print("\nAvailable Models:")
                for i, file in enumerate(model_files, 1):
                    print(f"  {i}. {file}")
                
                try:
                    choice = input("\nSelect model number to load: ").strip()
                    choice = int(choice) - 1
                    
                    if 0 <= choice < len(model_files):
                        model_path = os.path.join('models', model_files[choice])
                    else:
                        print("❌ Invalid selection")
                        return
                except ValueError:
                    print("❌ Please enter a valid number")
                    return
            else:
                print("❌ No models available")
                return
        
        try:
            self.system = AutonomousLearningSystem()
            self.system.agent.load_model(model_path)
            self.system.load_training_stats()
            
            print(f"✅ Model loaded successfully from {model_path}")
            print(f"   Trained episodes: {self.system.agent.episodes}")
            print(f"   Total steps: {self.system.agent.steps}")
            print(f"   Epsilon value: {self.system.agent.epsilon:.3f}")
            
            # عرض مقاييس الدقة إذا كانت متاحة
            accuracy_metrics = self.system.agent.get_accuracy_metrics()
            print(f"   Average accuracy: {accuracy_metrics['accuracy']:.3f}")
            print(f"   Average F1 score: {accuracy_metrics['f1_score']:.3f}")
            
            self.model_loaded = True
        
        except Exception as e:
            print(f"❌ Error loading model: {str(e)}")
            self.model_loaded = False

# ====================== الدالة الرئيسية ======================
def main():
    print("\n" + "="*70)
    print("🚀 AUTONOMOUS VULNERABILITY DETECTION SYSTEM")
    print("🎓 Advanced Graduation Project - Version 2.0")
    print("📅 Developed: " + datetime.now().strftime("%Y-%m-%d"))
    print("="*70)
    
    # التحقق من المكتبات المطلوبة
    try:
        import torch
        import gym
        import numpy as np
        import pandas as pd
        
        print("✅ All required libraries are installed")
        
        # عرض معلومات النظام
        print(f"\n💻 System Information:")
        print(f"  Operating System: {sys.platform}")
        print(f"  Python Version: {sys.version[:6]}")
        print(f"  PyTorch Version: {torch.__version__}")
        print(f"  CUDA Available: {torch.cuda.is_available()}")
        
        if torch.cuda.is_available():
            print(f"  GPU Device: {torch.cuda.get_device_name(0)}")
    
    except ImportError as e:
        print(f"❌ Missing library: {e}")
        print("Please install required libraries using:")
        print("pip install torch gym numpy pandas matplotlib seaborn scikit-learn")
        return
    
    # بدء واجهة المستخدم
    ui = UserInterface()
    ui.run()

# ====================== تشغيل النظام ======================
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nSystem stopped by user")
    except Exception as e:
        print(f"\n❌ Unexpected error: {str(e)}")
        print("Please check system settings and libraries")
    finally:
        print("\n" + "="*70)
        print("Thank you for using the Autonomous Vulnerability Detection System")
        print("="*70)